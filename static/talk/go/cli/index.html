<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Designing Command-Line Tools People Love</title>

		<meta name="description" content="Build command-line tools that are not only easy to learn, but that other developers are willing to maintain">
		<meta name="author" content="Carolyn Van Slyck">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="icon" type="image/png" href="images/favicon.ico"/>
		<link rel="stylesheet" href="../../revealjs/css/reveal.css">
		<link rel="stylesheet" href="../../revealjs/css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="../../revealjs/lib/css/zenburn.css">

		<link rel="stylesheet" href="../../revealjs/css/custom.css">

		<!-- Open links outside of presentation -->
		<base target="_blank">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../../revealjs/css/print/pdf.css' : '../../revealjs/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2 class="blue">
						Designing Command-Line Tools People Love
					</h2>

          			<img src="images/console-love.png" />

					<p>
						Carolyn Van Slyck<br/>
						Senior Software Engineer at Microsoft
					</p>

					<aside class="notes">

					</aside>
				</section>

				<section id="intention">
					<h2>Often CLIs aren't <span class="highlight">designed</span>,<br/>
						 functionality is added haphazardly</h2>

				<aside class="notes">
					Poor decisions now can be used against you later
				</aside>
				</section>

				<section id="goals">
					<h2>Design Goals</h2>

					<ul>
						<li>Predictable</li>
						<li>Task oriented</li>
						<li>Friendly to both humans and scripts</li>
						<li>Engineered</li>
					</ul>

					<aside class="notes">
						* predictable, consistent
						* band-aide when must
						* include tasks, composed commands
						* human and script friendly
						* Tests = less regressions but also people are less afraid to contribute
					</aside>
				</section>

				<section id="introduction">
					<h2>My CLI CV</h2>

					<aside class="notes">
						introduce the example projects before I show their code and discuss design
					</aside>
				</section>

				<section id="dvm">
					<h2>Docker Version Manager</h2>
					<img src="images/dvm.png" height="200px"/>
				</section>

				<section id="dep">
					<h2>dep</h2>

					<img src="images/dep.png" height="200px"/>
				</section>

				<section id="svcat">
					<img src="images/service-catalog.png" height="200px" />
				</section>

				<section id="porter">
					<img src="images/porter.png" height="200px"/>
				</section>

				<section id="command-design">
					<h2>Command Design</h2>

					<aside class="notes">
						Decide early, otherwise you are stuck with however it happened to work before you came up with a design
					</aside>
				</section>

				<section id="grammar">
					<h2>Pick your <span class="highlight">grammar</span></h2>

					<h3>A system of rules that defines the structure of a command</h3>

					<aside class="notes">
						* Do nouns go before or after the verb?
						* Do you hyphenate long flag names?
						* Do you use sub-commands, or is a flat hierarchy?
						* Got strong feelings about aliases?
						* Follow what works in your native language
						* Mostly be consistent
						* Break consistency in favor of domain at times
					</aside>
				</section>

				<section id="precedent">
					<h2>Understand <span class="highlight">precedent</span> in your ecosystem</h2>

					<ul style="padding-top: 2em;">
						<li>svcat follows kubectl</li>
						<li>dvm followed nvm (for a while)</li>
						<li>dep explicitly doesn't follow glide or npm</li>
						<li>porter is setting precedent</li>
					</ul>

					<aside class="notes">
						* muscle memory
						* know when it's helpful, and when you need to move beyond it
					</aside>
				</section>

				<section id="emote-cli">
					<h2>Let's design a CLI!</h2>

					<h1 class="highlight" style="padding-top:2em;">¯\_(ツ)_/¯</h1>
				</section>

				<section id="sentences">
					<h2>Commands that read like <span class="highlight">sentences</span> are easier to remember</h2>
				</section>

				<section id="emote-emoticons">
<pre><code class="huge plain" data-trim data-noescape>
$ emote add emoticon gopher --value ʕ •ᴥ•ʔ
added custom emoticon "gopher"

$ emote delete emoticon anxious
deleted custom emoticon "anxious"
</code></pre>
				</section>
				
				<section id="pos-arg-war">
					<h2>Avoid positional arguments where the order matters</h2>
				</section>

				<section id="emote-repos">
<pre><code class="huge plain" data-trim data-noescape>
$ emote add repo funk --url https://example.com/funk.json
</code></pre>

				<aside class="notes">
					Don't make people lookup the help text for this
					emote: name is the positional arg, everything else is flags
				</aside>
				</section>

				<section id="multi-pos-args">
<pre><code class="huge plain" data-trim data-noescape>
$ emote repo delete funk moar-funk
deleted funk and moar-funk
</code></pre>

				<aside class="notes">
					Here both positional arguments _are names_
				</aside>
				</section>

				<section id="outputs">
					<h2>Support <span class="highlight">automation</span> on your commands</h2>
					
					<aside class="notes">
						* Think about what's easiest for people and machines.
						* People care about seeing different data than when they are automating.
						* People first.
					</aside>
				</section>
				
				<section id="emote-json">
<pre><code class="huge plain" data-trim data-noescape>
$ emote list repos --output json
[
  {
    "name":"funk",
    "url":"https://example.com/funk.json",
	"size":100,
	"created":"2019-07-15T14:32:22Z"
  }
]
</code></pre>											
				</section>
					
				<section id="human-first">
					<h2>Default to <span class="highlight">human first</span> output</h2>

					<aside class="notes">
						* humanized dates
						* maybe show a subset of data that they want to see (avoid overwhelming)
						* yaml is not a human output
						* think about the task that they are accomplishing
					</aside>
				</section>

				<section id="emote-list-repos">
<pre><code class="huge plain" data-trim data-noescape>
$ emote list repos
NAME         CREATED           SIZE
funk         10 days ago       10
</code></pre>											
				</section>

				<section id="implicit-resource">
					<h2>Sometimes the <span class="highlight">resource is implicit</span> in the domain</h2>

					<aside class="notes">
						The binary name itself may be the resource or imply it
						emote -> emoticon
					</aside>
				</section>

<section id="emote-list">
<pre><code class="huge plain" data-trim data-noescape>
$ emote list
NAME               VALUE
shrug              ¯\_(ツ)_/¯
tableflip          (╯°□°）╯︵ ┻━┻
monocle            ಠ_ರೃ
</code></pre>		
</section>

				<section id="alias">
					<h2><span class="highlight">Aliases</span> provide balance between brevity and discoverability</h2>
				</section>

				<section id="emote-list2">
<pre><code class="huge plain" data-trim data-noescape>
$ emote emoticon list
NAME               VALUE
shrug              ¯\_(ツ)_/¯
tableflip          (╯°□°）╯︵ ┻━┻
monocle            ಠ_ರೃ
</code></pre>		
				</section>

				<section id="helptext">
					<h2>Customize your help text</h2>
					
					<aside class="notes">
						Frameworks can make it easy to customize
						This is your chance, tell people how to be the most successful at using your CLI
						Guide them down the happy path
						I'll often repeat my best advice both in helptext and on my online documentation,
						link them directly to online docs
					</aside>
				</section>

				<section id="alias-helptext">
<pre><code class="huge plain" data-trim data-noescape>
$ emote --help
emote helps you react in realtime

Resources:
  emoticons
  repos

Aliased Commands:
  list		List emoticons
</code></pre>	
				</section>

				<section id="shrug">
					<h2><span class="highlight">Task-oriented</span> commands are the most helpful</h2>
				</section>

				<section id="emote-shrug">
<pre><code class="huge plain" data-trim data-noescape>
$ emote shrug
¯\_(ツ)_/¯ copied to the clipboard

$ emote shrug --dest slack
Your slack status is now ¯\_(ツ)_/¯
</code></pre>
					
					<aside class="notes">
						This is why the tool is useful.
						This is why anyone is using it.
					</aside>
				</section>

				<section id="domain-over-grammar">
					<h2>Domain vs. Grammar</h2>

					<p style="padding: 2em 0">Use your <span class="highlight">judgement</span> about the domain when breaking with the grammar</p>
					
					<aside class="notes">
						example: emote list or shrug
						the domain is emoticons, it may be okay to drop the noun and be inconsistent
						the cli name itself _is_ a verb, so we cheat
					</aside>
				</section>

				<section id="dont-litter">
					<h2>Combine commands to make <span class="highlight">tasks</span> easier</h2>

					<aside class="notes">
						* If you can fix things in the API directly, do it
						* Sometimes, there is a flow and it makes sense to combine 2+ commands into a third
						* Allow the user to focus on the task, instead of getting lost in the steps
					</aside>
				</section>

				<section id="travis-encrypt">
<pre><code class="huge plain" data-trim data-noescape>
$ travis encrypt MY_SECRET_ENV=super_secret --add env
</code></pre>

					<ol>
						<li>Download the public key for your travis repository</li>
						<li>Encrypt the env var with the public key using openssl</li>
						<li>Insert an entry into .travis.yml with the encrypted value</li>
					</ol>
				</section>

					<section id="travis-evil">
<pre><code class="huge plain" data-trim data-noescape>
$ travis pubkey | jq -r .key > mykey.pub
$ echo 'MY_SECRET_ENV=super_secret' \ 
  | openssl rsautl -encrypt -pubin -inkey mykey.pub \
  | travis env add
</code></pre>

				</section>

				<section id="recap">
					<h2>Pause and Reflect</h2>
					
					<ul style="list-style: none">
						<li class="fragment">✅ Designed for Humans</li>
						<li class="fragment">✅ Task Oriented</li>
						<li class="fragment">❓ High Quality</li>
					</ul>

					<aside class="notes">
						Title: CLIs people -LOVE-
						Easy to learn and remember
						Solves their day-to-day tasks
					</aside>
				</section>

				<section id="soapbox">
					<h2>A great CLI needs to have <span class="highlight">high quality</span> code backing it</h2>

					<aside class="notes">
						First user touch point, needs to be rock solid
						Can't just be the burden of new/jr developers who graduate to backend
						Must be maintained so ... you will need testable code
						As high quality code as backend
						Respected, equal to backend or it will be shortchanged
					</aside>
				</section>

				<section id="frameworks">
					<h2>Frameworks</h2>

					<ul style="font-family: monospace; padding-top: 2em;">
						<li>spf13/cobra - Commands and Flags</li>
						<li>spf13/viper - Configuration Management</li>
						<li>spf13/afero - File System Abstraction</li>
						<li>dustin/go-humanize - Natural Language Units</li>
					</ul>

					<p style="padding-top: 2em;">Thank you, Steve Francia! 💖</p>

					<aside class="notes">
						Defacto in most cloudy CLIs such as docker, kuberentes
					</aside>
				</section>

				<section id="cobra">
					<h2>Why use spf13/cobra</h2>

					<ul>
						<li>CLI Framework / Main Entrypoint</li>
						<li>Command Routing</li>
						<li>Error Handling</li>
						<li>Help Text</li>
						<li>Flag Parsing and Validation</li>
					</ul>
				</section>

				<section id="cobra-usage">
					<h2>Getting Started with Cobra</h2>

<pre style="padding-top:2em;"><code class="big go" data-trim data-noescape>
func buildEmoteCommand() *cobra.Command {

	emote := &cobra.Command{
		Use:   "emote",
	}

	emote.AddCommands(buildShrugCommand())
	
	return emote
}
</code></pre>

				</section>

				<section id="cobra-usage-2">

<pre style="padding-top:2em;"><code class="big go" data-trim data-noescape>
func buildShrugCommand() *cobra.Command {

	shrug := &cobra.Command{
		Use: "shrug",
		
		Run: func(cmd *cobra.Command, args []string) {
			fmt.Println(`¯\_(ツ)_/¯`)
		},
	}

	return emote
}
</code></pre>
					<aside class="notes">
						For the sake of short slides I'm putting logic in my cobra wiring
						DO NOT DO THIS
						I'll show later how to separate this better
					</aside>
				</section>

				<section id="cobra-usage-3">

<pre style="padding-top:2em;"><code class="big go" data-trim data-noescape>
func main() {

	cmd := buildEmoteCommand()
	
	if err := cmd.Execute(); err != nil {
		// cobra prints the error so you don't have to
		os.Exit(1)
	}
}
</code></pre>
				</section>

				<section id="viper">
					<h2>Why use spf13/viper</h2>

					<ul>
						<li>Single combined configuration from multiple sources</li>
						<li>Reads from flags, config files, remote key/value stores, environment variables</li>
						<li>Smart defaulting: can tell if it was defaulted or set by the user</li>
						<li>Supports config files of multiple formats: json, yaml, toml, and more</li>
					</ul>
				</section>

				<section id="viper-init">
					<h2>Read Config Files of Any Type with Viper</h2>

<pre style="padding-top:2em;"><code class="big go" data-trim data-noescape>
type Manifest struct {
	Name    string `mapstructure:"name"` // mapstructure handles yaml, toml, json, hcl, etc
	Version string `mapstructure:"version"`
}

func Load(name, dir string) (*Manifest, error) {
	v := viper.New()
	if name == "" {
		v.SetConfigName(duffle.DuffleFilename)
	} else {
		v.SetConfigFile(filepath.Join(dir, name))
	}
	v.AddConfigPath(dir)
	err := v.ReadInConfig()
	if err != nil {
		return nil, fmt.Errorf("Error finding duffle config file: %s", err)
	}

	m := &Manifest{}
	v.Unmarshal(m)
	return m, nil
}
</code></pre>					

<p class="code-source">
	From <a href="https://github.com/deislabs/duffle/blob/master/pkg/duffle/manifest/load.go">duffle</a>
</p>

					<aside class="notes">
						viper can end up infecting your code if you aren't careful
					</aside>
				</section>

				<section id="afero">
					<h2>Why use spf13/afero</h2>

					<ul>
						<li>Lightweight filesystem abstraction</li>
						<li>Faster, more simple unit tests</li>
					</ul>
				</section>

				<section id="afero-usage">
					<h2>Replace ioutil with Afero</h2>

<pre style="padding-top: 2em;"><code class="big go" data-trim data-noescape>
ioutil.ReadFile("/etc/gopherfarts/config")

// vs.

var fs = afero.NewOsFs()
fs.ReadFile("/etc/gopherfarts/config")
</code></pre>	

					<aside class="notes">
						read a file from the file system using afero 
						tests later
						what can go wrong? 🤔
					</aside>
				</section>

				<section>
					<h2>Why use dustin/go-humanize?</h2>

					<ul>
						<li>Time: 6 hours ago</li>
						<li>Size: 83 MB</li>
						<li>Pluralize: 1 cat, 2 cats</li>
					</ul>
				</section>

				<section id="package-structure">
					<h2>Package Structure</h2>

					<ul style="padding-top: 2em;">
						<li>Keep cobra and viper usage in main package</li>
						<li>Write a standalone app for your CLI in a separate package</li>
					</ul>
					<aside class="notes">
						* anything in main, can't be reused by others
						* anything hidden in those cobra functions can't be reused by others, or easily tested!
						* Don't make people take dependencies on frameworks just to get at App type stuff
						* Generate a App as a side-effect
						* I don't care about pkg or whatever, just don't put those in the same package
					</aside>
				</section>

				<section id="cmd">
					<h2>main package</h2>

					<ul>
						<li>Isolates dependencies on cli frameworks</li>
						<li>Anything in here can't be exported</li>
						<li>This stuff is hard to test properly</li>
					</ul>

					<p style="padding-top:2em" class="highlight">Keep this as small as possible</p>
					
				</section>

				<section id="pkg">
					<h2>application package</h2>

					<ul>
						<li>Make functions that are 1:1 the commands in your CLI</li>
						<li>Create happy little packages for everything</li>
						<li>Hide your band-aides and API wrappers in here</li>
					</ul>

					<p style="padding-top:2em" class="highlight">Forget this is a CLI and follow your dreams 🌈</p>
					
				</section>

				<section id="package-structure-porter">
					<h2>Ideal Wiring in Main Package</h2>
<pre style="padding-top: 2em;"><code class="big go" data-trim data-noescape>
func buildBundleInstallCommand(p *porter.Porter) *cobra.Command {

	opts := porter.InstallOptions{}

	cmd := &cobra.Command{
		Use:   "install [NAME]",
		Short: "Install a bundle",
		
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.Validate(args, p.Context)
		},
		
		RunE: func(cmd *cobra.Command, args []string) error {
			return p.InstallBundle(opts)
		},

	return cmd
}
</code></pre>
					<p class="code-source">From <a href="https://github.com/deislabs/porter/blob/master/cmd/porter/bundle.go">porter install</a></p>

					<aside class="notes">
						* wire up exported functions from other packages to cobra
						* opts has unit tests to validate, makes it easier for people to code against the app
						* no need to write unit tests against this simple wiring other than that the command is present
					</aside>
				</section>

				<section id="application-context">
					<h2>Application Context</h2>

					<p>Pass in interfaces for input, output, filesystem so you can verify their contents in your tests</p>

				</section>

				<section id="context-porter">
					<h2>Porter's Application Context</h2>
<pre style="padding-top: 2em;"><code class="big go" data-trim data-noescape>
package portercontext

// Context holds references to external systems that need to be captured or modified in tests
type Context struct {
	Debug      bool
	FileSystem *afero.Afero
	In         io.Reader
	Out        io.Writer
	Err        io.Writer
	NewCommand CommandBuilder // Abstraction for executing binaries
}
</code></pre>
<p class="code-source">From <a href="https://github.com/deislabs/porter/blob/master/pkg/context/context.go">Porter</a></p>

<p><span class="comment">Yes, context is a horrible name. Call it whatever you like.</span> 😅</p>
				</section>

				<section id="composing-porter">
					<h2>Composing Porter's App</h2>

<pre style="padding-top: 2em;"><code class="big go" data-trim data-noescape>
package porter

// Porter is the logic behind the porter client.
type Porter struct {
	*portercontext.Context
}
</code></pre>
				</section>

				<section id="using-porter-app">
					<h2>Using Porter's App</h2>

<pre style="padding-top: 2em;"><code class="big go" data-trim data-noescape>
p := porter.NewPorter()

// Out comes from Context
fmt.Fprintf(p.Out, "Writing Dockerfile")

// FileSystem comes from Context
err = p.FileSystem.WriteFile("Dockerfile", contents, 0644)
</code></pre>

				</section>

				<section id="testing">
					<h2>Testing Strategies</h2>

					<aside class="notes">
						Payoff for spending this much engineering and thought on the CLI
						Safety net for new people contributing to your CLI
					</aside>
				</section>

				<section id="test-goals">
					<h2>Test Goals</h2>
	
					<ul>
						<li>Exercise the CLI validation, output and formatting</li>
						<li>Avoid retesting the App from the CLI's tests</li>
						<li>Safety net for new contributors</li>
						<li>Remove excuses for people who refuse to do "frontend stuff" 😇</li>
					</ul>
					
					<aside class="notes">
						
					</aside>
				</section>

				<section id="main-tests">
					<h2>What to test in main?</h2>
					
					<ul>
						<li>Are the commands defined in cobra?</li>
						<li>Are the flags declared, both with long and short forms?</li>
						<li>Do you have flag defaults set?</li>
						<li>Is the PreRunE wired up to your option's validation function?</li>
					</ul>
					
					<p align="center" class="highlight"><strong>Only test cobra/viper configuration</strong></p>
				</section>

				<section id="notmain-tests">
					<h2>What NOT to test in main?</h2>
					
					<ul>
						<li>Command logic</li>
						<li>Output formatting</li>
						<li>Command validation</li>
					</ul>
				</section>

				<section id="flag-validation-test">
					<h2>Porter Flag Validation Test</h2>
					<p class="code-title">cmd/porter/mixins_test.go</p>
<pre style="padding-top: 2em;"><code class="big go" data-trim data-noescape>
func TestBuildListMixinsCommand_BadFormat(t *testing.T) {
	p := porter.NewTestPorter(t)
	cmd := buildListMixinsCommand(p.Porter)
	cmd.ParseFlags([]string{"--output", "flarts"})

	err := cmd.PreRunE(cmd, []string{})

	require.NotNil(t, err)
	require.Contains(t, err.Error(), "invalid format: flarts")
}
</code></pre>
<p class="code-source">From <a href="https://github.com/deislabs/porter/blob/master/cmd/porter/mixins_test.go">Porter</a></p>

				</section>

				<section id="test-context">
					<h2>Test Context</h2>
<p class="code-title">pkg/context/helpers.go</p>
<pre><code class="big go" data-trim data-noescape>
type TestContext struct {
	*Context

	input  *bytes.Buffer
	output *bytes.Buffer
	T      *testing.T
}

// NewTestContext initializes a configuration suitable for testing, 
// with the output buffered, and an in-memory file system.
func NewTestContext(t *testing.T) *TestContext {
	...
}
</code></pre>
<p class="code-source">From <a href="https://github.com/deislabs/porter/blob/master/pkg/context/helpers.go">Porter</a></p>

				</section>

				<section id="test-App">
					<h2>Test App</h2>
<p class="code-title">pkg/porter/helpers.go</p>
<pre><code class="big go" data-trim data-noescape>
type TestPorter struct {
	*Porter
	TestConfig *config.TestConfig
}

// NewTestPorter initializes a porter test client, 
// with the output buffered, and an in-memory file system.
func NewTestPorter(t *testing.T) *TestPorter {
	...
}
</code></pre>
<p class="code-source">From <a href="https://github.com/deislabs/porter/blob/master/pkg/porter/helpers.go">Porter</a></p>

				</section>

				<section id="capture-output">
					<h2>Capturing Output in Tests</h2>
<p class="code-title">pkg/porter/version_test.go</p>
<pre><code class="big go" data-trim data-noescape>
func TestPrintVersion(t *testing.T) {
	pkg.Commit = "abc123"
	pkg.Version = "v1.2.3"
	p := NewTestPorter(t)

	p.PrintVersion()

	// Use our test structs to grab the captured output
	gotOutput := p.TestConfig.TestContext.GetOutput()

	wantOutput := "porter v1.2.3 (abc123)"
	if !strings.Contains(gotOutput, wantOutput) {
		t.Fatalf("invalid output:\nWANT:\t%q\nGOT:\t%q\n", wantOutput, gotOutput)
	}
}
</code></pre>
<p class="code-source">From <a href="https://github.com/deislabs/porter/blob/master/pkg/porter/version_test.go">porter version test</a></p>

				</section>

				<section id="test-filesystem">
					<h2>Testing with an InMemory FileSystem</h2>
					<p class="code-title">pkg/porter/create_test.go</p>
<pre><code class="big go" data-trim data-noescape>
func TestCreate(t *testing.T) {
	p := NewTestPorter(t)
	p.TestConfig.SetupPorterHome()

	err := p.Create()
	require.NoError(t, err)

	// Tests execute against in-memory afero file system
	configFileExists, err := p.FileSystem.Exists(config.Name)
	require.NoError(t, err)
	assert.True(t, configFileExists)
}
</code></pre>
<p class="code-source">From <a href="https://github.com/deislabs/porter/blob/master/pkg/porter/create_test.go">porter create test</a></p>

			</section>

			<section id="takeout">
				<h2>It's a bit anticlimatic really</h2>
			</section>

			<section id="takeout">
				<h2>Thank you</h2>

				<p><img src="../../../images/mlp-salute.png"/></p>
				<p><a href="http://twitter.com/carolynvs" target="_blank">@carolynvs</a></p>

				<p class="comment">
					Gopher artwork by Ashley McNamara <br/>
					licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 License
				</p>
			</section>

				
			</div>
			<slide-footer>
				<a href="http://carolynvs.com/cli">carolynvs.com/cli</a>
			</slide-footer>
		</div>

		<script src="../../revealjs/lib/js/head.min.js"></script>
		<script src="../../revealjs/js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,

				// use 16:9 aspect ratio
				width: 1600,
				height: 900,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				keyboard: {
					190: null // Disable blank screen hell
				},

				// Optional reveal.js plugins
				dependencies: [
					{ src: '../../revealjs/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../../revealjs/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../../revealjs/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../../revealjs/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../../revealjs/plugin/zoom-js/zoom.js', async: true },
					{ src: '../../revealjs/plugin/notes/notes.js', async: true },
					{ src: '../../revealjs/plugin/external/external.js', condition: function() { return !!document.querySelector( '[data-external]' ); } },
				]
			});

		</script>

	</body>
</html>
