Now let's use Porter to install Tabby Tracker _safely_.

No curl pipe bash for us! [SMILE]
						
For unfamiliar bundles, you can use porter explain to learn how to install it.

[porter explain --reference carolynvs/tabbycat-demo:v0.2.0]

Bundles have metadata that describes what the bundle is, its version, the credentials it needs to install, any parameters that you can use to customize the installation.

Explain gives you enough information to know what you need to pass to the porter install command (or later to the upgrade command).

Looking over my bundle, 

[highlight credentials]

I see that I'll need an Azure service principal, and 

[highlight parameter]

I can pick which region to use though it will default to my favorite, centralus.

[highlight this bundle uses the following tools]

I can also see that the bundle uses terraform and helm and 

[highlight outputs]

based on the outputs, it is going to create a Kubernetes cluster and a database.

That seems legit and makes me feel a bit more comfortable running the bundle since I can see exactly what credentials and tools the bundle will use.

Next, I'm going to tell Porter where it can lookup any credentials that the bundle needs, in this case an Azure service principal.

Instead of storing them in environment variables on my computer, I'm going to put them into a secret store.

[Show azure portal with keyvault]

Here I have Azure KeyVault setup with secrets for the service principal.

I'm using Azure but I could have used any secret store, like Hashicorp Vault.

Porter has something called "credential sets", which is a mapping between the credentials used by the bundle, and where porter can lookup those credentials.

When the bundle is run, Porter looks up the credentials just-in-time and injects them into the bundle.

This is great because it keeps sensitive values off of my dev machine and CI server.

[clear]

I'm going to run porter credentials generate to make a credential set, and pass it my bundle. 

[porter credentials generate azure --reference carolynvs/tabbycat-demo:v0.2.0]

Porter walks through each credential and prompts you for where that value is stored.

Mine are all in a secret store, so I can just enter in the key name for each value and this tells Porter where to get my credentials when it needs it later.

I realize that this is an extra step for installing something that you wouldn't have to do with curl pipe bash.

But remember that one of our goals was isolating the installation script from our local computer?

We don't want the installer to be able to snoop around and find juicy environment variables with tokens and credentials in them.

When Porter runs a bundle, the bundle executes inside a docker container.

Any credentials that the bundle needs, must be explicitly passed in.

A credential set lets me store a hint for porter on how to find my credentials, maybe I have one for my azure credentials, another for aws, or github.

I can define it once and then when I run a bundle that needs access, I can give the bundle that credential set without having to specify each time how to read them out of a secret store.

[clear]

Now that all this security stuff is out of the way, here's the "one-liner" to replace our curl pipe bash.

I can run porter install, give it my credentials, and the bundle to install and that's it.

[porter install tabbycats --cred azure --reference carolynvs/tabbycat-demo:v0.2.0]

Even though the bundle is using helm and terraform, I don't have to have those installed on my laptop, because the bundle, a docker container, has the right versions of each CLI installed inside along with my terraform files, and Helm charts.

Everything my app needs to install is inside that bundle.

It doesn't matter what I'm installing, it's the same porter install command.

[Watch the bundle install]

Cool, now that my app is installed, let's check it out.

The porter list command lets me see everything that I've installed with Porter.

[porter list]

And I can see more details about that installation with porter show.

[porter show tabbycats]

When it was installed, if it was successful and if I had specified any custom parameters when I installed it, they would show up here too.

What I want now is where my TabbyCats Tracker app is installed.

So I'm going to look at the outputs generated by the bundle with porter installation outputs list

[porter installation outputs list tabbycats]

The bundle saved all sorts of useful things. 

A connection string for the database it provisioned, the cluster's kubeconfig, the terraform state, and heres what I was looking for, the endpoint for my app.

[open the app in the web browser]

As you can see I am still an [airquote] _aspiring_ web designer but hopefully the cute tabby cats makes up for my CSS skills.

Seriously even if you aren't into Porter at this point, I hope [double finger point] that I have tricked you into installing the Tabby Cats browser plugin.

Since it made a cluster for me, let's poke around!

I'm going to save the kubeconfig

[porter installation outputs show kubeconfig -i tabbycats > kubeconfig]

and then use it with kubectl
[export KUBECONFIG=kubeconfig]

to see what was deployed
[kubectl get all]

[kubectl describe deploy/tabbycats-tabbycat-demo]

Here I want to call out just two things:

First, the image uses a digest, not a tag.

That is something that Porter can help you manage so that you aren't copying digests around which isn't as easy to work with as tags.

I'll show you in just a minute how Porter does that.

And the other thing you can see is that Porter injected the connection string for the database that the installation script created.

---

Let's go see the source code for the bundle and how it was made.

[open porter.yaml]

A bundle is defined by a porter.yaml file.
This manifest contains basic information about the bundle, and also has all the data
that you saw from porter explain.

[highlight the credentials]

Here you can see that I've declared that we need an Azure service principal, 

[highlight the parameter]

and also a region parameter.

Keep going and 

[highlight mixins]

it also declares what tools are inside the bundle by declaring "mixins".

Mixins are building blocks for bundles and help you use existing tools inside a bundle and have it work the way you'd expect.

Mixins install the tools inside the bundle's docker image, and map between the yaml you see here, and the final commands executed inside the bundle.

Mixins can make it easier to write the bundle, 

[scroll to the install action]

for example since we are using helm inside of the install action, it will automatically use the helm install command.

Mixins also help you extract data from a step and pass it into the next step in your installation.

[highlight the terraform outputs]

Here terraform created a cluster and database, and I'm grabbing those
out of that step 

[highlight the helm set calls]

and making them available to the helm chart that is run next.

Normally this type of stuff is all done with a bit of glue work in bash, and you could still do that if you wanted.

The mixins just make it easier to focus on the deployment logic.
